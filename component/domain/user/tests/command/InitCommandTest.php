<?php

namespace tests\framework\http;

use PhpAcadem\domain\User\command\InitCommand;
use PhpAcadem\domain\User\command\UserAddCommand;
use PhpAcadem\domain\User\UserInterface;
use PhpAcadem\domain\User\UserServiceInterface;
use PHPUnit\Framework\TestCase;
use Symfony\Component\Console\Command\Command;

class InitCommandTest extends TestCase
{
    protected $userService;
    protected $randomPassword;
    protected $wrongLogin;

    public function testInterface(): void
    {
        $userAddCommand = new InitCommand($this->createPdo(), $this->userService);
        $this->assertInstanceOf(Command::class, $userAddCommand);
    }

    /**
     * @param null $exception
     * @return \PDO
     */
    protected function createPdo(\Throwable $exception = null)
    {

        $pdo = $this->createMock(
            \PDO::class
        );
        $pdo->expects($this->any())
            ->method('query')
            ->will($this->returnCallback(function () use ($exception) {
                if ($exception) {
                    throw $exception;
                }
                return $this->createStatement();
            }));
        /** @var \PDO $pdo */
        return $pdo;
    }

    protected function createStatement($fetch = null)
    {
        $statement = $this->createMock(\PDOStatement::class);

        if ($fetch && is_array($fetch)) {
            $statement->expects($this->any())
                ->method('fetch')
                ->will($this->returnCallback(function () use ($fetch) {
                    return $fetch;
                }));
        }
        return $statement;
    }

    public function testConfigure(): void
    {
        $initCommand = new InitCommand($this->createPdo(), $this->userService);

        $this->assertEquals(InitCommand::COMMAND_NAME, $initCommand->getName());

    }

    public function testExecuteFail(): void
    {
        $pdo = $this->createPdo(new \PDOException());

        $initCommand = new InitCommand($pdo, $this->userService);

        $input = $this->createMock(\Symfony\Component\Console\Input\InputInterface::class);
        $output = $this->createMock(\Symfony\Component\Console\Output\OutputInterface::class);

        $result = self::callMethod($initCommand, 'execute', [$input, $output]);

        $this->assertEquals(UserAddCommand::COMMAND_ERROR_PARAMS, $result);
    }

    public static function callMethod($obj, $name, array $args = [])
    {
        $class = new \ReflectionClass($obj);
        $method = $class->getMethod($name);
        $method->setAccessible(true);
        return $method->invokeArgs($obj, $args);
    }

    public function testExecuteSuccess(): void
    {
        $pdo = $this->createPdo();

        $initCommand = new InitCommand($pdo, $this->userService);

        $input = $this->createMock(\Symfony\Component\Console\Input\InputInterface::class);
        $output = $this->createMock(\Symfony\Component\Console\Output\OutputInterface::class);

        $result = self::callMethod($initCommand, 'execute', [$input, $output]);

        $this->assertNull($result);
    }

    protected function setUp()/* The :void return type declaration that should be here would cause a BC issue */
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->userService = $this->getUserService();
    }

    protected function getUserService()
    {
        $userService = $this->createMock(
            UserServiceInterface::class
        );
        $userService->expects($this->any())
            ->method('create')
            ->will($this->returnCallback(function ($args) {
                $user = $this->createMock(UserInterface::class);
                return $user;
            }));

        $userService->expects($this->any())
            ->method('create')
            ->will($this->returnCallback(function ($args) {
                $user = $this->createMock(UserInterface::class);
                return $user;
            }));


        return $userService;
    }
}